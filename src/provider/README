Overview:
This project focuses on designing and implementing a weekly planner system to manage and schedule
events for users. It provides functionality to create or import a schedule for a user which can
then be interacted upon through ways such as creating, modifying and removing events from said
schedule with the ability to view the schedule in a textual format. Basic common knowledge of
planner/event systems is more than enough for use with this codebase. In terms of extensibility,
implementing a GUI and further developing more complex automated scheduling capabilities is
planned for future development.

Quick start:
To get started, one could either upload an XML to the system which will automatically create a
user and populate their schedule with the contents of the file. Additionally, users found in an
events participant list will also be added into the system. The other approach would be to
manually create a user and then add events to their schedule. Below are examples:
upload XML:
SystemImpl plannerSystem = new SystemImpl();
plannerSystem.uploadXML("schedule.xml");
Manually create user:
User user = new User("Bob");
List<String> participants = new ArrayList<>();
participants.add(user.getUsername());
Event event = new Event("CS3500", LocalDateTime.now(), LocalDateTime.now().plusHours(1),
                        "Churchill Hall 101", false, participants);
user.getSchedule().addEvent(event);

Key components & subcomponents:
- System/Planner System
    This is the main model representing the entire planner system. It handles the actual
    behaviours and functionalities of the planner (creating and/or modifying events, schedules
    and users) and links all the components together. It also handles reading and writing
    XML files for either importing or exporting a user's schedule. It is the basis of the program.
    - Event
        This component represents an event and all its details (name, start and end time, location
        and participants). An event is the foundation for everything else in the system.
    - Schedule
        This component represents a user's schedule which holds all the events a user is invited to.
        The schedule can be modified to add, modify and remove events for a user. It also provides
        functionality to turn a user's events into string format.
    - User
        This component represents a user within the system. Each user has a single schedule which
        holds all of their events. Their username is also unique within the system.
    - filereadwrite
        This component holds the functionalities for reading and writing XML files. This
        facilitates the uploading and saving of a user's schedule.
- View
    This is the view component of the planner system, allowing the planner system to be visualised
    and interpreted by the client. It is driven by the model.
    - Textual view
        This component renders and displays a user's schedule in a readable format. It visualises
        a user's schedule and provides every event's details (name, time, location, participants)
        in a structured format to provide an easier way to understand a user's schedule. The format
        follows the textual view from the assignment specifications.

Source organization:
Within the Model Package that is the source of all the functions of a Planner,
there are 5 classes and 1 interface:
src/model/Event.java: A class to represent events
src/model/Schedule.java: A class to represent a schedule that can holds multiple events
src/model/SystemImpl.java: A class to manipulate multiple users and their schedules
src/model/SystemInterface.java: An interface to provide a backbone for the functions in
                                systemImpl class
src/model/User.java: A class that represents users with their usernames and schedule
src/model/filereadwrite.java: A utility class to handle reading and writing XML files

Within the View Package that functions to all users to see the planner,
there is one class and 1 interface:
src/view/ViewImpl.java: A class that implements ViewInterFace and functions to display a message
                        that for users.
src/view/ViewInterface.java: An interface to provide a backbone for the function in ViewImpl.

Within the Test Package that functions to test all the functions in the model and view package,
there are 6 classes:
test/EventTests.java: A class to test methods in Test class and give examples of events
test/ScheduleTests.java: A class to test methods in Schedule class and give examples of schedules
test/SystemTests.java: A class to test methods in SystemImpl class and give examples of systems
test/UserTests.java: A class to test methods in User class and give examples of users
test/XMLReadWriteTests.java: A class to test methods in filereadwrite class
test/ViewTests.java: A class to test the toString() method in schedule class shows up in view

Changes for part 2:
We added 3 methods to the readOnlySystemInterface: getAllUsers(),
isConflictWithAllUsers(Event event), getUserEventList(User user)
The getAllUsers method returns a list of strings of all the users in our hashmap that contains all
the users in the system.
The isConflictWithAllUsers method returns a true or false based on the conflict status of the event
it takes in with the event it is comparing it to.
The getUserEventList method returns a list of events by taking in a user and extracting the user's
schedule and its events.
We also made a new class XMLReadWrite that replaced the utils class we had before. We put it into a
filereadwrite package. We made this change to write good documentation and better readability.

In assignment one, we had a toString method that had the functionality of outputting the textual
view. We put this method into our viewImplText class within our view package because this should be
part of the view's job and not the model's job.

We also changed how we handled time; previously, we simply did LocalDateTime.now() which would work,
but fail our tests as the day changed due to it calculating the date dynamically. Now, we base the
date on a set period in time which allows our tests to pass and overall makes handling dates and
weeks far less finicky.

Other than those changes, we just separated observations and mutations into the SystemInterface
and ReadOnlySystemInterface respectively.

For the view package, we added CreateEventFrame, ModifyOrRemoveEventFrame, and MainSystemFrame
classes. The CreateEventFrame class creates the create event frame for when someone clicks on
the create event button on the main system frame. The ModifyOrRemoveEventFrame class handles
the creation of the frame to modify or remove an event. This can be done when an event is clicked.
The MainSystemFrame class handles the planner view. This is where a user can switch user view,
create an event, and schedule event. The user can also add and save calendars.


Changes for part 3:
We made the SystemPlanner class an abstract class and had WorkhoursSystemPlanner and
AnytimeSystemPlanner class extend SystemPlanner and implement SystemInterface. We then supered all
the methods to reduce code duplication and only changed the method automaticallyScheduleEvent() so
that it could cater to the specific need of the planner type. We also made the SystemPlannerCreator
that served to hold the enum values to switch the planner types. In our PlannerRunner class we
altered the main method so that depending on the argument it receives (either "Anytime" or
"Workhours") the planner type will change accordingly. The difference between the two types are
in the way they schedule events. Anytime schedules the events anytime. Workhours only schedules
events from 9am to 5pm on weekdays. We made Workhours schedule events only if that event can placed
within one day. For example, if the duration of a event was more than 8 hours long or 480 minutes,
the event cannot be scheduled because it will take more than one day to complete the event. We
figured that an event scheduled in workhours should only be an event that can fit in one day
because realistically an event will not be prolonged to the next morning starting at 9am. If
anything, a new event should be made as a prolongation of the old event. We also made a new frame
called the ScheduleEventFrame that served as the frame for scheduling events. This frame is
similar to the other event frames but instead of asking for the start time and start dates, it
asks for the duration of an event that a user wants to schedule for multiple users.
Moving to the controller which was the main task of this assignment, we created two interfaces.
A Features interface that contained all our big methods that users can use to alter the view. For
example, we added the methods like addCalendar, saveCalendar, selectUser, createEvent,
scheduleEvent,removeEvent, modifyEvent that all were major functions that users can use to alter
their schedule. We then created a controller interface that just ran implemented the method run
to run the systemInterface model or the planner. Lastly, we created the Controller class that
implemented both interfaces and took in the view. The purpose of our controller was to connect the
methods/functions we made in the model to affect the view based on what the user clicked on the
view. For our tests, we updated our system tests, to test the functionality of our two new systems.
the WorkhoursSystemPlanner and the AnytimeSystemPlanner.

Extra Credit:
Resizable Views:
All parts of our planner and frames are resizable without creating any dislocations or changes
in dimensions. In order to do this we used precise number types such as doubles to calculate
whenever resizing is done. At the very end, we converted our double into an integer that our
planner can take in as a proper input. In doing so, we were able to make more precise calculations
of the planner dimensions. We also did not hard code any of the dimensions. We used keywords like
width or height of the planner to constantly resize the planner whenever users choose to resize it.

A Lenient Strategy:
Our lenient planner type scheduling strategy works completely. I created two helper methods that
make sure that the host and at least one participant is not conflicting with the earliest
schedule-able event. Lenient strategy methods can be found in the LenientSystemPlanner class in
model.